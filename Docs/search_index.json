[["data-management-using-r.html", "Chapter 2 Data Management using R 2.1 Basis System Seeting 2.2 Data Type in R 2.3 Data Structure in R 2.4 Function in R 2.5 Load Data 2.6 Basic Data Management 2.7 Package tidyr 2.8 Package dplyr 2.9 Package stringr 2.10 Package forcats 2.11 Package lubridate", " Chapter 2 Data Management using R 2.1 Basis System Seeting 2.1.1 Help and Packages Tools Global Options getwd() setwd(\"C:/.../\") Source: http://r-project.org Install and load Packages install.packages() library() library(help=\"pwr\") Releasing loaded packages: detach(package:pwr) remove.packages(\"pwr\") List all already installed packages: library() Help system Opens the (web) links to the manuals. help.start() Access help for specific functions ?sqrt help(sqrt) help(\"sqrt\") apropos(\"mean\") returns a list of function names that contain the expression mean (functions displayed in the loaded packages.) help(glm, try.all.packages=T) searches in all installed packages and returns the names of these packages. The help page for a function in a package that has not yet been loaded can then be displayed using the package option. Alternative help(glm, package=\"stats\") help.search(\"truncated\") or ??truncated searches for a specific word (here truncated) in the online help. RSiteSearch(\"truncated\") searches help pages, vignettes and task views for the keyword “truncated”. 2.1.2 Create Script Save a collection of R commands in a text file (R script) with the file extension “.R”. R-Studio: File- New File - R Script Comment hash symbol in R markdown 2.1.3 Basic Mathematische Operatoren &amp; Funktionen Figure 2.1: Basic Mathematische Operatoren &amp; Funktionen A Figure 2.2: Basic Mathematische Operatoren &amp; Funktionen B 5 !=2+2 TRUE &amp; FALSE TRUE | FALSE (4&gt;= 3|5==6) &amp; (4!=4) FALSE || (2 !=3) 7%/%2 18%%3 Inf + Inf + 2 Inf - Inf + 2 5/0 x &lt;- 1:7 (x &gt; 2) &amp;&amp; (x &lt; 5) (x &gt; 2) | (x &lt; 5) (x &gt; 2) || (x &lt; 5) 2.2 Data Type in R R has 6 basic data types. (In addition to the five listed below, there is also raw which will not be discussed in this workshop.) character numeric (real or decimal) integer logical complex Data structures are very important to understand because these are the objects you will manipulate on a day-to-day basis in R. Dealing with object conversions is one of the most common sources of frustration for beginners. Everything in R is an object. R has 6 basic data types. (In addition to the five listed below, there is also raw which will not be discussed in this workshop.) character numeric (real or decimal) integer logical complex Elements of these data types may be combined to form data structures, such as atomic vectors. When we call a vector atomic, we mean that the vector only holds data of a single data type. Below are examples of atomic character vectors, numeric vectors, integer vectors, etc. character: \"a\", \"swc\" numeric: 2, 15.5 integer: 2L (the L tells R to store this as an integer) logical: TRUE, FALSE complex: 1+4i (complex numbers with real and imaginary parts) R provides many functions to examine features of vectors and other objects, for example class() - what kind of object is it (high-level)? typeof() - what is the object’s data type (low-level)? length() - how long is it? What about two dimensional objects? attributes() - does it have any metadata? # Example x &lt;- &quot;dataset&quot; typeof(x) ## [1] &quot;character&quot; attributes(x) ## NULL y &lt;- 1:10 y ## [1] 1 2 3 4 5 6 7 8 9 10 typeof(y) ## [1] &quot;integer&quot; length(y) ## [1] 10 z &lt;- as.numeric(y) z ## [1] 1 2 3 4 5 6 7 8 9 10 typeof(z) ## [1] &quot;double&quot; R has many data structures. These include atomic vector list matrix data frame factors 2.3 Data Structure in R 2.3.1 Vectors A vector is the most common and basic data structure in R and is pretty much the workhorse of R. Technically, vectors can be one of two types: atomic vectors lists although the term “vector” most commonly refers to the atomic types not to lists. 2.3.1.1 The Different Vector Modes A vector is a collection of elements that are most commonly of mode character, logical, integer or numeric. You can create an empty vector with vector(). (By default the mode is logical. You can be more explicit as shown in the examples below.) It is more common to use direct constructors such as character(), numeric(), etc. vector() # an empty &#39;logical&#39; (the default) vector ## logical(0) vector(&quot;character&quot;, length = 5) # a vector of mode &#39;character&#39; with 5 elements ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; character(5) # the same thing, but using the constructor directly ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; numeric(5) # a numeric vector with 5 elements ## [1] 0 0 0 0 0 logical(5) # a logical vector with 5 elements ## [1] FALSE FALSE FALSE FALSE FALSE You can also create vectors by directly specifying their content. R will then guess the appropriate mode of storage for the vector. For instance: x &lt;- c(1, 2, 3) will create a vector x of mode numeric. These are the most common kind, and are treated as double precision real numbers. If you wanted to explicitly create integers, you need to add an L to each element (or coerce to the integer type using as.integer()). x1 &lt;- c(1L, 2L, 3L) Using TRUE and FALSE will create a vector of mode logical: y &lt;- c(TRUE, TRUE, FALSE, FALSE) While using quoted text will create a vector of mode character: z &lt;- c(&quot;Sarah&quot;, &quot;Tracy&quot;, &quot;Jon&quot;) 2.3.1.2 Examining Vectors The functions typeof(), length(), class() and str() provide useful information about your vectors and R objects in general. typeof(z) ## [1] &quot;character&quot; length(z) ## [1] 3 class(z) ## [1] &quot;character&quot; str(z) ## chr [1:3] &quot;Sarah&quot; &quot;Tracy&quot; &quot;Jon&quot; 2.3.1.3 Adding Elements The function c() (for combine) can also be used to add elements to a vector. z &lt;- c(z, &quot;Annette&quot;) z ## [1] &quot;Sarah&quot; &quot;Tracy&quot; &quot;Jon&quot; &quot;Annette&quot; z &lt;- c(&quot;Greg&quot;, z) z ## [1] &quot;Greg&quot; &quot;Sarah&quot; &quot;Tracy&quot; &quot;Jon&quot; &quot;Annette&quot; 2.3.1.4 Vectors from a Sequence of Numbers You can create vectors as a sequence of numbers. series &lt;- 1:10 seq(10) ## [1] 1 2 3 4 5 6 7 8 9 10 seq(from = 1, to = 10, by = 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 ## [16] 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 ## [31] 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 ## [46] 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 ## [61] 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 ## [76] 8.5 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 ## [91] 10.0 2.3.1.5 Missing Data R supports missing data in vectors. They are represented as NA (Not Available) and can be used for all the vector types covered in this lesson: x &lt;- c(0.5, NA, 0.7) x &lt;- c(TRUE, FALSE, NA) x &lt;- c(&quot;a&quot;, NA, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) x &lt;- c(1+5i, 2-3i, NA) The function is.na() indicates the elements of the vectors that represent missing data, and the function anyNA() returns TRUE if the vector contains any missing values: x &lt;- c(&quot;a&quot;, NA, &quot;c&quot;, &quot;d&quot;, NA) y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) is.na(x) ## [1] FALSE TRUE FALSE FALSE TRUE is.na(y) ## [1] FALSE FALSE FALSE FALSE FALSE anyNA(x) ## [1] TRUE anyNA(y) ## [1] FALSE 2.3.1.6 Other Special Values Inf is infinity. You can have either positive or negative infinity. 1/0 ## [1] Inf NaN means Not a Number. It’s an undefined value. 0/0 ## [1] NaN 2.3.1.7 What Happens When You Mix Types Inside a Vector? R will create a resulting vector with a mode that can most easily accommodate all the elements it contains. This conversion between modes of storage is called “coercion”. When R converts the mode of storage based on its content, it is referred to as “implicit coercion”. For instance, can you guess what the following do (without running them first)? xx &lt;- c(1.7, &quot;a&quot;) xx &lt;- c(TRUE, 2) xx &lt;- c(&quot;a&quot;, TRUE) You can also control how vectors are coerced explicitly using the as.&lt;class_name&gt;() functions: as.numeric(&quot;1&quot;) ## [1] 1 as.character(1:2) ## [1] &quot;1&quot; &quot;2&quot; 2.3.2 Matrix In R matrices are an extension of the numeric or character vectors. They are not a separate type of object but simply an atomic vector with dimensions; the number of rows and columns. As with atomic vectors, the elements of a matrix must be of the same data type. m &lt;- matrix(nrow = 2, ncol = 2) m ## [,1] [,2] ## [1,] NA NA ## [2,] NA NA dim(m) ## [1] 2 2 You can check that matrices are vectors with a class attribute of matrix by using class() and typeof(). m &lt;- matrix(c(1:3)) class(m) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(m) ## [1] &quot;integer&quot; While class() shows that m is a matrix, typeof() shows that fundamentally the matrix is an integer vector. Matrices in R are filled column-wise. m &lt;- matrix(1:6, nrow = 2, ncol = 3) Other ways to construct a matrix m &lt;- 1:10 dim(m) &lt;- c(2, 5) This takes a vector and transforms it into a matrix with 2 rows and 5 columns. Another way is to bind columns or rows using rbind() and cbind() (“row bind” and “column bind”, respectively). x &lt;- 1:3 y &lt;- 10:12 cbind(x, y) ## x y ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(x, y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 10 11 12 You can also use the byrow argument to specify how the matrix is filled. From R’s own documentation: mdat &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE) mdat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 11 12 13 Elements of a matrix can be referenced by specifying the index along each dimension (e.g. “row” and “column”) in single square brackets. mdat[2, 3] ## [1] 13 2.3.3 List In R lists act as containers. Unlike atomic vectors, the contents of a list are not restricted to a single mode and can encompass any mixture of data types. Lists are sometimes called generic vectors, because the elements of a list can by of any type of R object, even lists containing further lists. This property makes them fundamentally different from atomic vectors. A list is a special type of vector. Each element can be a different type. Create lists using list() or coerce other objects using as.list(). An empty list of the required length can be created using vector() x &lt;- list(1, &quot;a&quot;, TRUE, 1+4i) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i x &lt;- vector(&quot;list&quot;, length = 5) # empty list length(x) ## [1] 5 The content of elements of a list can be retrieved by using double square brackets. x[[1]] ## NULL Vectors can be coerced to lists as follows: x &lt;- 1:10 x &lt;- as.list(x) length(x) ## [1] 10 Lists can be extremely useful inside functions. Because the functions in R are able to return only a single object, you can “staple” together lots of different kinds of results into a single object that a function can return. A list does not print to the console like a vector. Instead, each element of the list starts on a new line. Elements are indexed by double brackets. Single brackets will still return a(nother) list. If the elements of a list are named, they can be referenced by the $ notation (i.e. xlist$data). 2.3.4 Data Frame A data frame is a very important data type in R. It’s pretty much the de facto data structure for most tabular data and what we use for statistics. A data frame is a special type of list where every element of the list has same length (i.e. data frame is a “rectangular” list). Data frames can have additional attributes such as rownames(), which can be useful for annotating data, like subject_id or sample_id. But most of the time they are not used. Some additional information on data frames: Usually created by read.csv() and read.table(), i.e. when importing the data into R. Assuming all columns in a data frame are of same type, data frame can be converted to a matrix with data.matrix() (preferred) or as.matrix(). Otherwise type coercion will be enforced and the results may not always be what you expect. Can also create a new data frame with data.frame() function. Find the number of rows and columns with nrow(dat) and ncol(dat), respectively. Rownames are often automatically generated and look like 1, 2, …, n. Consistency in numbering of rownames may not be honored when rows are reshuffled or subset. 2.3.4.1 Creating Data Frames by Hand To create data frames by hand: dat &lt;- data.frame(id = letters[1:10], x = 1:10, y = 11:20) dat ## id x y ## 1 a 1 11 ## 2 b 2 12 ## 3 c 3 13 ## 4 d 4 14 ## 5 e 5 15 ## 6 f 6 16 ## 7 g 7 17 ## 8 h 8 18 ## 9 i 9 19 ## 10 j 10 20 2.3.4.2 Useful Data Frame Functions head() - shows first 6 rows tail() - shows last 6 rows dim() - returns the dimensions of data frame (i.e. number of rows and number of columns) nrow() - number of rows ncol() - number of columns str() - structure of data frame - name, type and preview of data in each column names() or colnames() - both show the names attribute for a data frame sapply(dataframe, class) - shows the class of each column in the data frame The following table summarizes the one-dimensional and two-dimensional data structures in R in relation to diversity of data types they can contain. Dimensions Homogenous Heterogeneous 1-D atomic vector list 2-D matrix data frame Lists can contain elements that are themselves muti-dimensional (e.g. a lists can contain data frames or another type of objects). Lists can also contain elements of any length, therefore list do not necessarily have to be “rectangular”. However in order for the list to qualify as a data frame, the length of each element has to be the same. 2.4 Function in R my.fun &lt;- function(x1 ,x2) (x1 + x2)/2 # order my.fun &lt;- function(x1 ,x2){ (x1 + x2)/2 } # order my.fun &lt;- function(x1 ,x2){ y &lt;- (x1 + x2)/2 y }# order my.fun &lt;- function(x1 ,x2){ y &lt;- (x1 + x2)/2 return(y) } # Calling the function: my.fun(100, 200) # order my.fun(x1 = 100, x2 = 200) # order my.fun(x2 = 200, x1 = 100) 2.5 Load Data 2.5.1 Package readr Figure 2.3: Data Import: CHEAT SHEET Figure 2.4: Data Import: CHEAT SHEET 2.5.2 Import csv data The Scan function returns a list or vector. This makes the scanning function less useful for entering “rectangular” data mydata1 &lt;- read.csv(&quot;~/Desktop/SASUniversityEdition/myfolders/Daten/CRP.csv&quot;, sep=&quot;;&quot;, header=TRUE) mydata2 &lt;- scan(&quot;~/Desktop/SASUniversityEdition/myfolders/Daten/CRP.csv&quot;, sep=&quot;;&quot;, what = list(&quot;integer&quot;,&quot;numeric&quot;)) 2.5.3 Import txt data test.semi &lt;- read.table(&quot;https://stats.idre.ucla.edu/wp-content/uploads/2016/02/testsemicolon.txt&quot;, header=T, sep=&quot;;&quot;) print(test.semi) pfad &lt;- &quot;~/Desktop/SASUniversityEdition/myfolders/Daten&quot; mydata3 &lt;- read.table(file.path(pfad, &quot;CRP.csv&quot;), header=TRUE, sep=&quot;;&quot;, dec = &quot;,&quot;, skip=9) 2.5.4 Import excel data read.xlsx slow for large data sets (worksheet with more than 100 000 cells) read.xlsx2 is faster on big files compared to read.xlsx function. ## install.packages(&quot;xlsx&quot;) library(&quot;xlsx&quot;) read.xlsx(file, sheetIndex, header=TRUE, colClasses=NA) read.xlsx2(file, sheetIndex, header=TRUE, colClasses=&quot;character&quot;) 2.5.5 Import stata data library(foreign) test.stata &lt;- read.dta(&quot;https://stats.idre.ucla.edu/stat/data/test.dta&quot;) print(test.stata) 2.5.6 Import SAS data library(sas7bdat) data &lt;- read.sas7bdat(&quot;~/Desktop/SASUniversityEdition/myfolders/Daten/uis.sas7bdat&quot;) View(data) 2.5.7 Copy from clipboard copdat &lt;- read.delim(&quot;clipboard&quot;) yourdata &lt;- copdat 2.5.8 Save and write objective in R 2.5.8.1 Save as R-Datei path &lt;- &quot;C:/Users/zbai/Projects/00_Project/00 PMS_VENUS/VENUS_CIR/01_Datasets&quot; saveRDS(save_objective, file = file.path(path, &quot;dataname.rds&quot; )) save_objective &lt;- readRDS(file = file.path(path, &quot;dataname.rds&quot; )) 2.5.8.2 write.table and write.csv # quote：字符串是否使用引号表示，默认为TRUE，也就是使用引号表示 # row.names：是否导出行序号，默认为TRUE，也就是导出行序号 # col.names：是否导出列名，默认为TRUE，也就是导出列名 # sep：分隔符，默认为空格（” “），也就是以空格为分割列 write.table (data ,file =&quot;~/Desktop/f.csv&quot;, row.names = FALSE, col.names =FALSE, quote =FALSE) 2.5.8.3 write.foreign Save as SPSS- und SAS- Datei library(&quot;foreign&quot;) datafile &lt;- tempfile() codefile &lt;- tempfile() write.foreign(esoph, datafile, codefile, package=&quot;SAS&quot;) file.show(datafile) file.show(codefile) unlink(datafile) unlink(codefile) 2.5.8.4 write.xlsx # Write the first data set in a new workbook write.xlsx(USArrests, file = &quot;./01_Datasets/myworkbook.xlsx&quot;, sheetName = &quot;USA-ARRESTS&quot;, append = FALSE) # Add a second data set in a new worksheet write.xlsx(mtcars, file = &quot;myworkbook.xlsx&quot;, sheetName=&quot;MTCARS&quot;, append=TRUE) # Add a third data set write.xlsx(iris, file = &quot;myworkbook.xlsx&quot;, sheetName=&quot;IRIS&quot;, append=TRUE) 2.5.9 Save the plot File formats for exporting plots: pdf(“rplot.pdf”): pdf file png(“rplot.png”): png file jpeg(“rplot.jpg”): jpeg file postscript(“rplot.ps”): postscript file bmp(“rplot.bmp”): bmp file win.metafile(“rplot.wmf”): windows metafile # 1. Open a pdf file pdf(&quot;rplot.pdf&quot;) # 2. Create a plot plot(x = my_data$wt, y = my_data$mpg, pch = 16, frame = FALSE, xlab = &quot;wt&quot;, ylab = &quot;mpg&quot;, col = &quot;#2E9FDF&quot;) # 3. Close the pdf file dev.off() 2.6 Basic Data Management 2.6.1 apply family 2.7 Package tidyr 2.7.1 CHEAT SHEET Figure 2.5: Data Wrangling with dplyr and tidyr Figure 2.6: Data Wrangling with dplyr and tidyr 2.7.2 Pivoting One variable might be spread across multiple columns. One observation might be scattered across multiple rows. pivot_longer() pivot_wider() library(&quot;tidyr&quot;) table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4a %&gt;% pivot_longer(c(`1999`, `2000`), names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table2 %&gt;% pivot_wider(names_from = type, values_from = count) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 ## missing values ## last observation carried forward treatment &lt;- tribble( ~ person, ~ treatment, ~response, &quot;Derrick Whitmore&quot;, 1, 7, NA, 2, 10, NA, 3, 9, &quot;Katherine Burke&quot;, 1, 4 ) treatment %&gt;% fill(person) ## # A tibble: 4 × 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 Derrick Whitmore 2 10 ## 3 Derrick Whitmore 3 9 ## 4 Katherine Burke 1 4 2.7.3 gather and spread ## prepare data olddata_wide &lt;- read.table(header=TRUE, text=&#39; subject sex control cond1 cond2 1 M 7.9 12.3 10.7 2 F 6.3 10.6 11.1 3 F 9.5 13.1 13.8 4 M 11.5 13.4 12.9 &#39;) olddata_wide$subject &lt;- factor(olddata_wide$subject) olddata_long &lt;- read.table(header=TRUE, text=&#39; subject sex condition measurement 1 M control 7.9 1 M cond1 12.3 1 M cond2 10.7 2 F control 6.3 2 F cond1 10.6 2 F cond2 11.1 3 F control 9.5 3 F cond1 13.1 3 F cond2 13.8 4 M control 11.5 4 M cond1 13.4 4 M cond2 12.9 &#39;) olddata_long$subject &lt;- factor(olddata_long$subject) ## factor_key将新键列视为一个因子（而不是字符向量） data_long &lt;- gather(olddata_wide, condition, measurement, control:cond2, factor_key=TRUE) ########################################################## # Äquivalent # keycol &lt;- &quot;condition&quot; # valuecol &lt;- &quot;measurement&quot; # gathercols &lt;- c(&quot;control&quot;, &quot;cond1&quot;, &quot;cond2&quot;) # gather_(olddata_wide, keycol, valuecol, gathercols) # ## subject sex condition measurement ## 1 1 M control 7.9 ## 2 2 F control 6.3 ## 3 3 F control 9.5 ## 4 4 M control 11.5 ## 5 1 M cond1 12.3 ## 6 2 F cond1 10.6 ## 7 3 F cond1 13.1 ## 8 4 M cond1 13.4 ## 9 1 M cond2 10.7 ## 10 2 F cond2 11.1 ## 11 3 F cond2 13.8 ## 12 4 M cond2 12.9 ########################################################## data_wide &lt;- spread(data=olddata_long, key = condition, value = measurement, convert = T) data_wide %&gt;% str ## &#39;data.frame&#39;: 4 obs. of 5 variables: ## $ subject: Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 2 3 4 ## $ sex : chr &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; ## $ cond1 : num 12.3 10.6 13.1 13.4 ## $ cond2 : num 10.7 11.1 13.8 12.9 ## $ control: num 7.9 6.3 9.5 11.5 2.7.4 separate and unite table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) ## # A tibble: 6 × 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 table5 %&gt;% unite(new, century, year) ## # A tibble: 6 × 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19_99 745/19987071 ## 2 Afghanistan 20_00 2666/20595360 ## 3 Brazil 19_99 37737/172006362 ## 4 Brazil 20_00 80488/174504898 ## 5 China 19_99 212258/1272915272 ## 6 China 20_00 213766/1280428583 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) ## # A tibble: 6 × 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 2.8 Package dplyr Package ‘dplyr’ 2.8.1 CHEAT SHEET Figure 2.7: Data Transformation with dplyr Figure 2.8: Data Transformation with dplyr 2.8.2 across library(&quot;dplyr&quot;) iris %&gt;% as_tibble() %&gt;% mutate(across(c(Sepal.Length, Sepal.Width), round)) ## # A tibble: 150 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5 4 1.4 0.2 setosa ## 2 5 3 1.4 0.2 setosa ## 3 5 3 1.3 0.2 setosa ## 4 5 3 1.5 0.2 setosa ## 5 5 4 1.4 0.2 setosa ## 6 5 4 1.7 0.4 setosa ## 7 5 3 1.4 0.3 setosa ## 8 5 3 1.5 0.2 setosa ## 9 4 3 1.4 0.2 setosa ## 10 5 3 1.5 0.1 setosa ## # ℹ 140 more rows 2.8.3 arrange ## Missing values are always sorted at the end: data(&quot;flights&quot;,package=&quot;nycflights13&quot;) arrange(flights, year, month, day) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ℹ 336,766 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ## in descending order: arrange(flights, desc(dep_delay)) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 9 641 900 1301 1242 1530 ## 2 2013 6 15 1432 1935 1137 1607 2120 ## 3 2013 1 10 1121 1635 1126 1239 1810 ## 4 2013 9 20 1139 1845 1014 1457 2210 ## 5 2013 7 22 845 1600 1005 1044 1815 ## 6 2013 4 10 1100 1900 960 1342 2211 ## 7 2013 3 17 2321 810 911 135 1020 ## 8 2013 6 27 959 1900 899 1236 2226 ## 9 2013 7 22 2257 759 898 121 1026 ## 10 2013 12 5 756 1700 896 1058 2020 ## # ℹ 336,766 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ## group_by by_cyl &lt;- mtcars %&gt;% group_by(cyl) ## 无视之前的分组 by_cyl %&gt;% arrange(desc(wt)) ## # A tibble: 32 × 11 ## # Groups: cyl [3] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 2 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## 3 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 4 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 5 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 ## 6 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 7 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 8 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 9 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 10 15 8 301 335 3.54 3.57 14.6 0 1 5 8 ## # ℹ 22 more rows ## 在之前的分组内再排序 by_cyl %&gt;% arrange(desc(wt), .by_group = TRUE) ## # A tibble: 32 × 11 ## # Groups: cyl [3] ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 2 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 3 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 ## 4 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 5 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 6 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 7 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 8 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 9 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 10 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## # ℹ 22 more rows 2.8.4 coalesce # Or match together a complete vector from missing pieces y &lt;- c(1, 2, NA, NA, 5) z &lt;- c(NA, NA, 3, 4, 5) coalesce(y, z) ## [1] 1 2 3 4 5 # Supply lists by with dynamic dots vecs &lt;- list( c(1, 2, NA, NA, 5), c(NA, NA, 3, 4, 5) ) coalesce(!!!vecs) ## [1] 1 2 3 4 5 2.8.5 filter data(&quot;flights&quot;,package=&quot;nycflights13&quot;) filter(flights, month == 1, day == 1) ## # A tibble: 842 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ℹ 832 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, month == 11 | month == 12) ## # A tibble: 55,403 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # ℹ 55,393 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; filter(flights, month %in% c(11, 12)) ## # A tibble: 55,403 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # ℹ 55,393 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ## Missing values,use is.na(x) df &lt;- tibble(x = c(1, NA, 3)) filter(df, is.na(x) | x &gt; 1) ## # A tibble: 2 × 1 ## x ## &lt;dbl&gt; ## 1 NA ## 2 3 2.8.6 if_else x &lt;- factor(sample(letters[1:5], 10, replace = TRUE)) ifelse(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) ## [1] NA 2 NA 2 3 NA 1 3 2 NA ## 与ifelse不同，if_else保留类型 if_else(x %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x, factor(NA)) ## [1] &lt;NA&gt; b &lt;NA&gt; b c &lt;NA&gt; a c b &lt;NA&gt; ## Levels: a b c d e 2.8.7 join ## left join: 共有 ## full join: 全部 ## left join: 以左边为主 ## 选取变量 left join data(&quot;flights&quot;,package=&quot;nycflights13&quot;) data(&quot;airlines&quot;,package=&quot;nycflights13&quot;) data(&quot;weather&quot;,package=&quot;nycflights13&quot;) flights2 &lt;- flights %&gt;% select(year:day, hour, origin, dest, tailnum, carrier) head(flights2) ## # A tibble: 6 × 8 ## year month day hour origin dest tailnum carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA 2.8.8 mutate ## mutate() flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) 2.8.9 select data(&quot;flights&quot;,package=&quot;nycflights13&quot;) select(flights, year, month, day) ## # A tibble: 336,776 × 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # ℹ 336,766 more rows select(flights, year:day) ## # A tibble: 336,776 × 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # ℹ 336,766 more rows select(flights, -(year:day)) ## # A tibble: 336,776 × 16 ## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 517 515 2 830 819 11 UA ## 2 533 529 4 850 830 20 UA ## 3 542 540 2 923 850 33 AA ## 4 544 545 -1 1004 1022 -18 B6 ## 5 554 600 -6 812 837 -25 DL ## 6 554 558 -4 740 728 12 UA ## 7 555 600 -5 913 854 19 B6 ## 8 557 600 -3 709 723 -14 EV ## 9 557 600 -3 838 846 -8 B6 ## 10 558 600 -2 753 745 8 AA ## # ℹ 336,766 more rows ## # ℹ 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; ## 辅助函数 helper functions can use within select(): ## starts_with(&quot;abc&quot;): matches names that begin with “abc”. ## ends_with(&quot;xyz&quot;): matches names that end with “xyz”. ## contains(&quot;ijk&quot;): matches names that contain “ijk”. ## num_range(&quot;x&quot;, 1:3): matches x1, x2 and x3. ## ignore.case选项表示忽略大小写。 select(iris, contains(&quot;etal&quot;, ignore.case = TRUE)) ## Petal.Length Petal.Width ## 1 1.4 0.2 ## 2 1.4 0.2 ## 3 1.3 0.2 ## 4 1.5 0.2 ## 5 1.4 0.2 ## 6 1.7 0.4 ## 7 1.4 0.3 ## 8 1.5 0.2 ## 9 1.4 0.2 ## 10 1.5 0.1 ## 11 1.5 0.2 ## 12 1.6 0.2 ## 13 1.4 0.1 ## 14 1.1 0.1 ## 15 1.2 0.2 ## 16 1.5 0.4 ## 17 1.3 0.4 ## 18 1.4 0.3 ## 19 1.7 0.3 ## 20 1.5 0.3 ## 21 1.7 0.2 ## 22 1.5 0.4 ## 23 1.0 0.2 ## 24 1.7 0.5 ## 25 1.9 0.2 ## 26 1.6 0.2 ## 27 1.6 0.4 ## 28 1.5 0.2 ## 29 1.4 0.2 ## 30 1.6 0.2 ## 31 1.6 0.2 ## 32 1.5 0.4 ## 33 1.5 0.1 ## 34 1.4 0.2 ## 35 1.5 0.2 ## 36 1.2 0.2 ## 37 1.3 0.2 ## 38 1.4 0.1 ## 39 1.3 0.2 ## 40 1.5 0.2 ## 41 1.3 0.3 ## 42 1.3 0.3 ## 43 1.3 0.2 ## 44 1.6 0.6 ## 45 1.9 0.4 ## 46 1.4 0.3 ## 47 1.6 0.2 ## 48 1.4 0.2 ## 49 1.5 0.2 ## 50 1.4 0.2 ## 51 4.7 1.4 ## 52 4.5 1.5 ## 53 4.9 1.5 ## 54 4.0 1.3 ## 55 4.6 1.5 ## 56 4.5 1.3 ## 57 4.7 1.6 ## 58 3.3 1.0 ## 59 4.6 1.3 ## 60 3.9 1.4 ## 61 3.5 1.0 ## 62 4.2 1.5 ## 63 4.0 1.0 ## 64 4.7 1.4 ## 65 3.6 1.3 ## 66 4.4 1.4 ## 67 4.5 1.5 ## 68 4.1 1.0 ## 69 4.5 1.5 ## 70 3.9 1.1 ## 71 4.8 1.8 ## 72 4.0 1.3 ## 73 4.9 1.5 ## 74 4.7 1.2 ## 75 4.3 1.3 ## 76 4.4 1.4 ## 77 4.8 1.4 ## 78 5.0 1.7 ## 79 4.5 1.5 ## 80 3.5 1.0 ## 81 3.8 1.1 ## 82 3.7 1.0 ## 83 3.9 1.2 ## 84 5.1 1.6 ## 85 4.5 1.5 ## 86 4.5 1.6 ## 87 4.7 1.5 ## 88 4.4 1.3 ## 89 4.1 1.3 ## 90 4.0 1.3 ## 91 4.4 1.2 ## 92 4.6 1.4 ## 93 4.0 1.2 ## 94 3.3 1.0 ## 95 4.2 1.3 ## 96 4.2 1.2 ## 97 4.2 1.3 ## 98 4.3 1.3 ## 99 3.0 1.1 ## 100 4.1 1.3 ## 101 6.0 2.5 ## 102 5.1 1.9 ## 103 5.9 2.1 ## 104 5.6 1.8 ## 105 5.8 2.2 ## 106 6.6 2.1 ## 107 4.5 1.7 ## 108 6.3 1.8 ## 109 5.8 1.8 ## 110 6.1 2.5 ## 111 5.1 2.0 ## 112 5.3 1.9 ## 113 5.5 2.1 ## 114 5.0 2.0 ## 115 5.1 2.4 ## 116 5.3 2.3 ## 117 5.5 1.8 ## 118 6.7 2.2 ## 119 6.9 2.3 ## 120 5.0 1.5 ## 121 5.7 2.3 ## 122 4.9 2.0 ## 123 6.7 2.0 ## 124 4.9 1.8 ## 125 5.7 2.1 ## 126 6.0 1.8 ## 127 4.8 1.8 ## 128 4.9 1.8 ## 129 5.6 2.1 ## 130 5.8 1.6 ## 131 6.1 1.9 ## 132 6.4 2.0 ## 133 5.6 2.2 ## 134 5.1 1.5 ## 135 5.6 1.4 ## 136 6.1 2.3 ## 137 5.6 2.4 ## 138 5.5 1.8 ## 139 4.8 1.8 ## 140 5.4 2.1 ## 141 5.6 2.4 ## 142 5.1 2.3 ## 143 5.1 1.9 ## 144 5.9 2.3 ## 145 5.7 2.5 ## 146 5.2 2.3 ## 147 5.0 1.9 ## 148 5.2 2.0 ## 149 5.4 2.3 ## 150 5.1 1.8 ## 将几个变量移到数据框的开头 select(flights, time_hour, air_time, everything()) ## # A tibble: 336,776 × 19 ## time_hour air_time year month day dep_time sched_dep_time ## &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 05:00:00 227 2013 1 1 517 515 ## 2 2013-01-01 05:00:00 227 2013 1 1 533 529 ## 3 2013-01-01 05:00:00 160 2013 1 1 542 540 ## 4 2013-01-01 05:00:00 183 2013 1 1 544 545 ## 5 2013-01-01 06:00:00 116 2013 1 1 554 600 ## 6 2013-01-01 05:00:00 150 2013 1 1 554 558 ## 7 2013-01-01 06:00:00 158 2013 1 1 555 600 ## 8 2013-01-01 06:00:00 53 2013 1 1 557 600 ## 9 2013-01-01 06:00:00 140 2013 1 1 557 600 ## 10 2013-01-01 06:00:00 138 2013 1 1 558 600 ## # ℹ 336,766 more rows ## # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, ## # dest &lt;chr&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt; ## rename rename(flights, tail_num = tailnum) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ℹ 336,766 more rows ## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, ## # tail_num &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 2.8.10 summarise ## with group_by by_day &lt;- group_by(flights, year, month, day) summarise(by_day, delay = mean(dep_delay, na.rm = TRUE)) ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.55 ## 9 2013 1 9 2.28 ## 10 2013 1 10 2.84 ## # ℹ 355 more rows ## pipe, %&gt;%: delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarise( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) delays ## # A tibble: 96 × 4 ## dest count dist delay ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABQ 254 1826 4.38 ## 2 ACK 265 199 4.85 ## 3 ALB 439 143 14.4 ## 4 ATL 17215 757. 11.3 ## 5 AUS 2439 1514. 6.02 ## 6 AVL 275 584. 8.00 ## 7 BDL 443 116 7.05 ## 8 BGR 375 378 8.03 ## 9 BHM 297 866. 16.9 ## 10 BNA 6333 758. 11.8 ## # ℹ 86 more rows ## 进行任何汇总时，最好都包含一个计数（n（））或一个非缺失值的计数 ## count=n(), ## non_miss=sum(!is.na(arr_delay)), ## quo()函数来求多值, “!!!”是引用终值并解析操作符，使用对象为元素为引用的列表或向量，它将引用的表达式解析并计算，每个列表元素都释放为summarize()函数的参数。另有“!!”操作符针对非列表对象 data(&quot;cuckoos&quot;, package = &quot;DAAG&quot;) var &lt;- list(quo(mean(length)), quo(sd(length)), quo(mean(breadth)), quo(sd(breadth))) cuckoos %&gt;% group_by(species) %&gt;% summarise(!!! var) ## # A tibble: 6 × 5 ## species `mean(length)` `sd(length)` `mean(breadth)` `sd(breadth)` ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 hedge.sparrow 23.1 1.05 16.8 0.534 ## 2 meadow.pipit 22.3 0.920 16.7 0.383 ## 3 pied.wagtail 22.9 1.07 16.5 0.450 ## 4 robin 22.6 0.682 16.4 0.548 ## 5 tree.pipit 23.1 0.880 16.7 0.450 ## 6 wren 21.1 0.754 15.8 0.313 ## Äquivalent cuckoos %&gt;% group_by(species) %&gt;% summarise(mw_length = mean(length), mw_breadth = mean(breadth)) %&gt;% arrange(mw_length, mw_breadth) ## # A tibble: 6 × 3 ## species mw_length mw_breadth ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 wren 21.1 15.8 ## 2 meadow.pipit 22.3 16.7 ## 3 robin 22.6 16.4 ## 4 pied.wagtail 22.9 16.5 ## 5 tree.pipit 23.1 16.7 ## 6 hedge.sparrow 23.1 16.8 2.9 Package stringr 2.9.1 CHEAT SHEET Figure 2.9: strings with stringr: CHEAT SHEET Figure 2.10: strings with stringr: CHEAT SHEET 2.10 Package forcats 2.10.1 CHEAT SHEET Figure 2.11: Factors with forcats: CHEAT SHEET 2.11 Package lubridate 2.11.1 CHEAT SHEET Figure 2.12: Dates and times with lubridate: CHEAT SHEET Figure 2.13: Dates and times with lubridate: CHEAT SHEET "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
