[["data-management-using-sas.html", "Chapter 3 Data Management using SAS 3.1 Input data into SAS 3.2 Format the variables 3.3 Array 3.4 Retain 3.5 Data utilities 3.6 Clean Up", " Chapter 3 Data Management using SAS 3.1 Input data into SAS 3.1.1 Native datasets input libname libref &quot;dir_location&quot;; data ds; set libref.sasfilename; /* Note: no file extension */ ... run; data ds; set &quot;dir_location\\sasfilename.sas7bdat&quot;; /* Windows only */ set &quot;dir_location/sasfilename.sas7bdat&quot;; /* works on all OS including Windows */ run; 3.1.2 Reading free formatted data instream DATA data1; INPUT make $ model $ mpg weight price; CARDS; AMC Concord 22 2930 4099 AMC Pacer 17 3350 4749 AMC Spirit 22 2640 3799 Buick Century 20 3250 4816 Buick Electra 15 4080 7827 ; RUN; 3.1.3 Reading fixed formatted data instream It need to provide the beginning and ending column numbers for each variable. DATA data2; INPUT make $ 1-5 model $ 6-12 mpg 13-14 weight 15-18 price 19-22; CARDS; AMC Concord2229304099 AMC Pacer 1733504749 AMC Spirit 2226403799 BuickCentury2032504816 BuickElectra1540807827 ; RUN; 3.1.4 INFILE: Reading fixed formatted data from an external file The data3.dat file: AMC Concord2229304099 AMC Pacer 1733504749 AMC Spirit 2226403799 BuickCentury2032504816 BuickElectra1540807827 DATA cars3; INFILE &quot;~/path/data3.dat&quot;; INPUT make $ 1-5 model $ 6-12 mpg 13-14 weight 15-18 price 19-22; RUN; *** with special (comma) delimited *** tab delimited: DELIMITER=&#39;09&#39;x; *** comma delimited: delimiter=&#39;,&#39;; AMC,Concord,22,2930,4099 AMC,Pacer,17,3350,4749 AMC,Spirit,22,2640,3799 Buick,Century,20,3250,4816 Buick,Electra,15,4080,7827 DATA cars5; INFILE &quot;~/path/data3.dat&quot; delimiter=&#39;,&#39;; INPUT make $ model $ mpg weight price; RUN; 3.1.5 Write the SAS File libname diss &#39;c:dissertation&#39;; data diss.salary; input sal1996-sal2000 ; cards; 10000 10500 11000 12000 12700 14000 16500 18000 22000 29000 ; run; data &#39;c:dissertationsalarylong&#39;; input Salary1996-Salary2000 ; cards; 10000 10500 11000 12000 12700 14000 16500 18000 22000 29000 ; run; 3.1.6 Import csv data PROC IMPORT datafile=&quot;Z:\\path\\data4.csv&quot; out=outname dbms=csv replace; delimiter=&quot;;&quot;; getnames=yes; Guessingrows=MAX; RUN; 3.1.7 %Import Import all SAS datasets available in a specific folder Macro Variables Description folder_path File path with the data that are to be imported; delete_all If delete_all is unequal 1 then all datasets in the work-library are deleted, else if it is 1 no datasets are deleted; fname&amp;i Macro variable that contains the dataset name total Number of all datasets within a folder %macro Import (folder_path, delete_all); *** delete all datasets if delete_all is 1; %if &amp;delete_all ne 1 %then %do; proc datasets library=work kill nolist; run; quit; dm log &#39;clear&#39;; %end; libname IMPORT &quot;&amp;folder_path&quot;; *** definition of folder with the datasets; proc sql; create table m_dataset_list as select distinct memname from dictionary.tables where libname=&quot;IMPORT&quot; and memtype=&quot;DATA&quot;; quit; *** declare macro variables containing the name of a dataset in the specified folder and their overall number; data m_dataset_list; set m_dataset_list end=last; retain i 0; i=i+1; call symput(&#39;fname&#39;||trim(left(put(i,8.))),scan(trim(memname),1,&#39;.&#39;)); if last then call symput(&#39;total&#39;,trim(left(put(i,8.)))); run; *** import by means of the macro variables defined above ; libname libdata &quot;&amp;folder_path&quot;; libname library (libdata); %do i=1 %to &amp;total; data work.&amp;&amp;fname&amp;i; set libdata.&amp;&amp;fname&amp;i; run; %end; %mend Import; %Import (folder_path=Z:\\...\\, delete_all=); 3.1.8 URL filename urlhandle url &#39;http://www.math.smith.edu/sas/testdata&#39;; filename urlhandle url &#39;http://www.math.smith.edu/sas/testdata&#39; user=&#39;your_username&#39; pass=&#39;your_password&#39;; proc import datafile=urlhandle out=ds dbms=dlm; run; 3.1.9 Infile Read multiple raw data files * data step to read in data; data mydata; length inname $ 100; input inname $; infile dummy filevar=inname end=EOF; do until (EOF); * PUT YOUR INPUT STATEMENT HERE TO READ IN YOUR DATA; input year 1-4 name $ 6-28 party $ 30-34 born 35-38 died 40-43 age 45-46 stborn $ 48-49 stelec $ 51-52 religion $ 54-65 elecvote 67-69 popvote 71-78; * DO ANY PROCESSING OF THE DATA HERE (E.G. COMPUTING NEW VARIABLES); output; end; cards; c:winners1.txt c:winners2.txt run; 3.1.10 Generate automatic file name If you create multiple data sets in SAS, you may want to name them in an automated way. How to create a file name based on date and time. Such a file naming process will 1) prevent you from providing the same file name to two different data sets, and 2) allow you to see when the file was first created. data tsave; do i = 1 to 10; do time = 1 to 5; y = rannor(1232+i + time); output; end; end; run; data _null_; cdate = &quot;&amp;SYSDATE9&quot;; ctime = &quot;&amp;SYSTIME&quot;; time_string = cdate||&quot;_&quot;||translate(ctime, &quot;_&quot;, &quot;:&quot;); call symput(&#39;mytime&#39;, time_string); run; data &quot;c:tempnewdata_&amp;mytime&quot;; set tsave; run; 3.2 Format the variables 3.2.1 Proc format proc format; value eye_CAT 1 = &quot;OD&quot; 2 = &quot;OS&quot;; value AR_CAT 1 = &quot;^{unicode 2264} 3° absolute rotation&quot; 2 = &quot;^{unicode 2264} 5° absolute rotation&quot; 3 = &quot;^{unicode 2264} 7° absolute rotation&quot; 4 = &quot;^{unicode 2264} 10° absolute rotation&quot; 5 = &quot;^{unicode 2264} 20° absolute rotation&quot; 6 = &quot;^{unicode 2264} 30° absolute rotation&quot;; run; 3.2.2 Copy and combine SAS format libraries libname first &quot;etempdata1&quot;; libname second &quot;etempdata2&quot;; proc catalog cat=first.FORMATS; copy out=second.FORMATS; run; 3.2.3 Build a format from a dataset Outcode Outname 101 Aberdeen 102 Altrincham 103 Ashford 104 Barnsley 105 Basildon 106 Basingstoke 107 BathFirst data work.outfmt(keep=start label fmtname); set work.outlets(rename=(outcode=start outname=label)); fmtname=&#39;outfmt&#39;; run; proc format library=work cntlin=work.outfmt; run; 3.2.4 Output format as datasets proc format library=work cntlout=format_dataset; run; ,0 3.2.5 Delete the format proc catalog catalog=work.formats; delete eye_CAT.format Visit_CAT.format; run; 3.3 Array 3.3.1 Defining array array-name {n} &lt;$&gt;&lt;length&gt; &lt;array-elements&gt; &lt;(initial-value-list)&gt;; \\[ \\begin{array}{|l|l|} \\hline \\text { Component } &amp; \\text { Description } \\\\ \\hline \\text { array-name } &amp; \\text { a valid SAS name that will be used to identify the group of variables } \\\\ \\hline \\mathrm{n} &amp; \\begin{array}{l} \\text { a subscript that refers to the number of elements or variables in the array that should be enclosed in either } \\\\ \\text { parentheses ( ), braces }\\{\\} \\text { , or brackets [ ] } \\end{array} \\\\ \\hline \\$ &amp; \\text { a component added to the statement to specify that the elements within the array are of character type } \\\\ \\hline \\text { length } &amp; \\text { a common length of the elements in the array } \\\\ \\hline \\text { array-elements } &amp; \\text { a list of the variables to be part of the array that must be all the same type, either all numeric or all character } \\\\ \\hline \\text { initial-value-list } &amp; \\text { a list of initial values for each of the array elements } \\\\ \\hline \\end{array} \\] simple examples array charsamp {5} $ 10 varc1 varc2 varc3 varc4 varc5; array numsamp (*) var1 var2 var3; array initsamp [2] $ init1 init2 (‘A’, ‘B’); Using Arrays in simple iterative DO loop do i=1 to 5; if numsamp[i] =. then numsamp[i] = 0; end; do i=1 to dim(numsamp); if numsamp[i] =. then numsamp[i] = 0; end; 3.3.2 Format multiple variables data sample_sae2; set sample_sae1; array saen {*} _aesdth _aeslife _aeshosp _aesdisab _aescong _aesmie; array saec {*} $1 aesdth aeslife aeshosp aesdisab aescong aesmie; do i=1 to dim(saec); if saen{i} = 1 then saec{i} = &#39;Y&#39;; else if saen{i} = 0 then saec{i} = &#39;N&#39;; end; run; Custom Formats proc format; value YN 1 = &#39;Y&#39; 0 = &#39;N&#39;; run; do i=1 to dim(saec); if ~missing(saen{i}) then saec{i} = put(saen{i},yn.); end; Format the summary statistics length contivar $200. n_c mean_c std_c min_c q1_c median_c q3_c max_c $100.; contivar =&quot;&quot;; array stat_num {*} n nmiss mean std min q1 median q3 max; array stat_char {*} n_c nmiss_c mean_c std_c min_c q1_c median_c q3_c max_c; *** make sure only variable no mis, otherwise variable miss is uninitialized; if n ne . then n_c = strip(put(round(n,1.),8.)); if nmiss ne . then nmiss_c = strip(put(round(nmiss,1.),8.)); if mean ne . then Mean_c = strip(put(round(mean,0.001),8.3)); if std ne . then Std_c = strip(put(round(std,0.001),8.3)); if min ne . then Min_c = strip(put(round(min,0.01),8.2)); if q1 ne . then Q1_c = strip(put(round(q1,0.001),8.3)); if median ne . then Median_c = strip(put(round(median,0.001),8.3)); if Q3 ne . then Q3_c = strip(put(round(q3,0.001),8.3)); if Max ne . then Max_c = strip(put(round(max,0.01),8.2)); if nmiss ne . then nmiss_p = divide (nmiss,_freq_); if nmiss ne . then nmiss_p_c = &quot;^R/RTF&#39;\\ql&#39; &quot; ||&quot; &quot; || strip(&quot;(&quot; || put(round (nmiss_p*100,0.1),5.1) || &quot;)&quot;); do stat=1 to dim(stat_char); if stat_num[stat] ge 100 then stat_char[stat] = &quot;^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); else if stat_num[stat] ge 10 then stat_char[stat] = &quot; ^_^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); else if stat_num[stat] ge 0 then stat_char[stat] = &quot; ^_^_^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); else if stat_num[stat] le -100 then stat_char[stat] = &quot;^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); else if stat_num[stat] le -10 then stat_char[stat] = &quot;^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); else if stat_num[stat] ge -1 then stat_char[stat] = &quot;^_^R/RTF&#39;\\qr&#39; &quot; || strip(stat_char[stat]); end; 3.3.3 2*2 arrays data anon_D06_glossary; LENGTH Description $200.; *** 6 Groups (COLs), max. 4 Subgroups (ROWs); array grps_subgrps{5,6} ( 0 1 2 3 4 5 01 11 21 31 41 51 . 12 22 32 . . . . . 33 . . . . . 34 . .); do i = 1 to dim2(grps_subgrps); IF grps_subgrps[1,i] EQ &amp;GROUP. THEN DO; do j = 2 to dim1(grps_subgrps); if grps_subgrps[j,i] ne . then do; Description = &amp;label.; GROUP = grps_subgrps[1,i]; SUBGROUP = grps_subgrps[j,i]; output; end; end; END; end; drop grps_subgrps: i j; set anon_D06_fmt (in = a); run; 3.3.4 Dynamic Element List using Macro Variables proc sql noprint; select distinct NAME into :NEWFLAGS separated by &quot; &quot; from dictionary.columns where libname = &quot;WORK&quot; and memname = &quot;SAMPLEPROC1&quot; and upcase(NAME) contains &quot;_FLAG&quot;; quit; array newfl {*} &amp;newflags.; 3.4 Retain 3.4.1 Generate Serial Number data abcd; input x y; cards; 1 25 1 28 1 27 2 23 2 35 2 34 3 25 3 29 ; run; data aaa; set abcd; retain z 0; z = z + 1; run; ***Cumulative Score; data aaa; set abcd; retain z 0; z = z + y; run; ***Generate Serial Number by Group; proc sort data = abcd; by x; run; data aaa; set abcd; retain z; if first.x then z = 1; else z = z + 1; by x; run; 3.4.2 Change from Basilne data data_a; set data_b; by RD_IOL_TYP subject_id eye Visit; *** calculate the CFB and CFM1; retain baseline baseline2; if first.eye then do; baseline = .; baseline2=.; end; if first.eye and &amp;var. ne . then do; if Visit = 1 then baseline = &amp;var.; end; if VISIT = 5 and &amp;var. ne . then do; baseline2 = &amp;var.; end; if &amp;var. ne . then do; if baseline ne . or baseline2 ne . then do; if VISIT = 5 and baseline ne . then CFB1 = &amp;var. - baseline; *** split CFB off, better for report; if VISIT = 6 and baseline ne . then CFB2 = &amp;var. - baseline; if VISIT = 6 and baseline2 ne . then CFM1 = &amp;var. - baseline2; end; end; keep RD_IOL_TYP subject_id eye visit &amp;var. CFB1 CFB2 CFM1 ITT PP; run; 3.5 Data utilities 3.5.1 %Scan Scan function: scan(s,n,“char”) means to extract the nth string from the string string with char as the delimiter, syntax (syntax) scan(s,n) When n is a positive number, extract n characters from the end of the character s scan(s,n) When n is a negative number, extract n characters from the character s scan(s,n&lt;,list-of-delimiters&gt;) If a delimiter is specified, only the delimiter will be extracted. If not specified, it will be split according to the commonly used delimiter. The default delimiter is: space. &lt;(+ &amp;! $ *); ^-/,% | etc. or a combination %macro VAC; %MACRO HL;*** Enable editor code highlighting, delete when finalising; %MEND HL; %do i = 1 %to 2; %let va_cat = CDVA CDVA_dec; %let var =&amp;i.; %let va = %SCAN (&amp;va_cat, &amp;var); data VENUS_T8_2_3_4_5_D01; set VENUS_T8_2_3_4_5_D01; by subject_id eye visit ; *** generate baseline CDVA CDVA_dec; retain base_&amp;va. ; if first.eye then base_&amp;va. = .; if first.eye and &amp;va. ne . then do; if VISIT eq 1 then base_&amp;va. = &amp;va.; end; %end;run; %mend VAC; %VAC; %macro mylogit1(all_deps); %let k=1; %let dep = %scan(&amp;all_deps, &amp;k); %do %while(&quot;&amp;dep&quot; NE &quot;&quot;); title &quot;dependent variable is &amp;dep&quot;; proc logistic data=xxx des; model &amp;dep = ind1 ind2; run; %let k = %eval(&amp;k + 1); %let dep = %scan(&amp;all_deps, &amp;k); %end; %mend; *run the program for the first three v&#39;s; %mylogit1(v1 v2 v3) %macro mylogita(indata, all_deps, indvars =, myout =_out ); %let k=1; %let dep = %scan(&amp;all_deps, &amp;k); %do %while(&amp;dep NE); title &quot;The dependent variable is &amp;dep&quot;; title2 &quot;The independent variables are &amp;indvars&quot;; proc logistic data=&amp;indata des outest=est&amp;k; model &amp;dep = &amp;indvars; run; %let k = %eval(&amp;k + 1); %let dep = %scan(&amp;all_deps, &amp;k); %end; data &amp;myout; set %do i = 1 %to &amp;k - 1; est&amp;i %end; ; run; %mend; *run the program; %mylogita(xxx, v1 v2 v3, indvars = ind1 ind2, myout = myparms) title; proc print data = myparms; var _name_ intercept ind1 ind2; run; 3.5.2 %eval and %syseval The %SYSEVALF function performs floating-point arithmetic and returns a value that is formatted using the BEST32. format. %let k = 1; %let tot = &amp;k + 1; %put &amp;tot; 1 + 1 %let tot = %eval(&amp;k + 1); %put &amp;tot; 2 %let tot = %sysevalf(&amp;k + 1.234); %put &amp;tot; 2.234 %let a = 2; %let b = 2.1; %put The result with SYSEVALF is: %sysevalf(&amp;a + &amp;b); %put BOOLEAN conversion: %sysevalf(&amp;a + &amp;b, boolean); %put INTEGER conversion: %sysevalf(&amp;a + &amp;b, integer); %put CEIL conversion: %sysevalf(&amp;a +&amp;b, ceil); %put FLOOR conversion: %sysevalf(&amp;a +&amp;b, floor); 3.5.3 Macro variable status %SYMEXIST: Used to judge whether a macro variable exists, and its parameter is the name of the macro variable. If the macro variable exists, it returns 1; otherwise, it returns 0. %let a1=1; %let re1=%symexist(a1); %let re2=%symexist(a2); %put re1=&amp;re1 re2=&amp;re2; %SYMGLOBL: Used to determine whether a macro variable is a global macro variable Check Macro Variable The DEFINED macro returns a value of 0 (false) if the argument is the name of a non-existent macro variable. It returns a 1 if the macro variable exists in the global macro environment. *MVAR The name of a macro variable; %macro defined (mvar); %local dsid rc scope; /** Open the vmacro view which contains info about macor vars **/ %let dsid=%sysfunc(open(sashelp.vmacro (where=(name=&quot;%upcase(&amp;mvar)&quot;)))); /** Fetch a record into the pdv if it exists **/ %let rc=%sysfunc(fetch(&amp;dsid)); /** Return varnum 1, the scope **/ %let scope = %sysfunc(getvarc(&amp;dsid,1)); /** Close the view **/ %let rc=%sysfunc(close(&amp;dsid)); %if &amp;scope = GLOBAL %then 1; %else 0; %mend; %global test; %let test=3; %macro testit; %if %defined(test) %then %put TEST is defined as &amp;test; %else %put TEST is undefined; %mend; %testit; %SYSMACEXIST: used to judge whether a macro program exists in the Work.SASMacr catalog, if it exists, it returns 1, otherwise it returns 0. 3.5.4 %SYSFUNC %SYSFUNC allows one to perform nearly ever SAS function on one’s macro variables. %macro procA; &amp; %mend procA; %macro procB; D %mend procB; %let D = TEST; %let C=%nrstr(%procB); %let X=%str(%procA&amp;C); %put Y1 = %sysfunc(substr(&amp;X, 1)); %put Y3 = %sysfunc(substr(&amp;X, 3)); *** Solution; %procA = &amp; %procB = D &amp;D = TEST &amp;C = %nrstr(%procB) = %procB (not soloved) &amp;X = %str(%procA&amp;C) = %procA&amp;C (soloved) = &amp;%procB Y1 = %sysfunc(substr(&amp;X, 1)) = %sysfunc(substr(&amp;%procB, 1)) = &amp;%procB = &amp;D Y3 = %sysfunc(substr(&amp;X, 3)) = %sysfunc(substr(&amp;%procB, 3)) = procB 3.5.5 Quoting Function %STR、%NRSTR、%QUOTE、%NRQUOTE、%BQUOTE、%NRBQUOTE、%SUPERQ、%UNQUOTE、%QSAN、%QSUBSTR、%QSYSFUNC、%QUPCASE 3.5.6 Call Symput The Symput and symget functions can pass information to or from the data step. When we want to get the information in the data step, there are two functions that are particularly useful. You can use symput to get the information in the data step into the macro variable, and when we want to get the information from the data in the macro variable into the data step, we will use symget. Call symput — call symput(‘new_macro_variable’, value_in_string_format) Call symputx () will remove the spaces before and after the second parameter value symget —symget(‘macro_variable’) 3.5.6.1 Populating Macro Variables data _NULL_; set VENUS_analysis_sets_subj(where=(RD_IOL_TYP=1)) end=eof; if eof then call symputx(&#39;n_SESsubj_Lara&#39;, _n_); run; %put &amp;n_SESsubj_Tecn.; *** A set of Macro Variables; data Venus_t8_2_3_5_2_Num; merge Venus_t8_2_3_5_2_Means Venus_t8_2_3_5_2_Num_cat; by analysis_set RD_IOL_TYP subgroup visit; if RD_IOL_TYP=1 then Treatment=&quot;LARA&quot;; if RD_IOL_TYP=2 then Treatment=&quot;TECN&quot;; if N = . then N = 0; Name = &quot;Num&quot;|| &quot;_&quot; ||trim(Analysis_set)|| &quot;_&quot; ||trim(Treatment)|| &quot;_&quot; ||strip(subgroup)|| &quot;_&quot; ||put(visit,1.); do _N_=1 to 240; call symputx(Name, N); end; run; 3.5.6.2 SQL into /*** Using SQL ***/ /*** One Macro Variable ***/ PROC SQL; RESET NOPRINT; SELECT PUT(MEAN(height),4.1) INTO : avgheight FROM sashelp.class ; RESET PRINT; %PUT macro variable AVGHEIGHT: [&amp;avgheight]; /*** Two Macro Variables ***/ PROC SQL; SELECT MAX(height), MIN(height) INTO : max_height , : min_height FROM sashelp.class ; QUIT; %PUT macro variable MAX_FNAME: [&amp;max_height]; %PUT macro variable MIN_FNAME: [&amp;min_height]; /*** More Variables ***/ proc sql noprint; select name, Population into :country1 - :country4, :pop1 - :pop3 from sql.countries; %put &amp;country1 &amp;pop1; %put &amp;country2 &amp;pop2; %put &amp;country3 &amp;pop3; %put &amp;country4; /***Create macro variable in string***/ DATA _NULL_; SET thirteens END=done; LENGTH fname_string $ 9999; RETAIN fname_string; fname_string = CATX(&#39; / &#39;,fname_string,fname); IF done THEN CALL SYMPUT(&#39;fnames&#39;,TRIM(fname_string) ); RUN; %PUT FNAMES: [&amp;fnames]; /*** Outpuit: FNAMES: [Alice / Barbara / Jeffrey] ***/ PROC SQL; SELECT fname INTO : fnames SEPARATED BY &#39; / &#39; FROM thirteens ; QUIT; %PUT FNAMES: [&amp;fnames]; 3.5.7 Call Execute 3.5.7.1 data null Good way to replease %IF %THEN statements, %IF %THEN statements cannot appear in open code. These statements are legal but only within a macro definition %if &amp;city = Boston %then %do; proc means data=beantown; var pahk youh caah; run; %end; %else %if &amp;city = New York %then %do; proc means data=big_apple; var a nominal egg; run; %end; /*CALL EXECUTE is a DATA step statement that means: “Run this code.” */ ods html; data sales; call execute (&#39;proc print data=sales; run;&#39;); amount=5; run; data _null_; set sales end=nomore; total + amount; if nomore; if (total &lt; 1000000) then call execute(&#39; proc means data=sales; class state; var amount; title &quot;Sales by State&quot;; run; &#39;); else call execute(&#39; proc means data=sales; class state year; var amount; title &quot;Sales by State and Year&quot;; run; &#39;); run; 3.5.7.2 Split the datasets data _null_; set sashelp.class; call execute(&#39;data work.&#39;||strip(name)||&#39;; set sashelp.class; where name=&quot;&#39;||strip(name)||&#39;&quot;; run;&#39;); run; /*First observation with name Alfred*/ data work.Alfred; set sashelp.class; where name=&quot;Alfred&quot;; run; /*Second observation with name Alice*/ data work.Alice; set sashelp.class; where name=&quot;Alice&quot;; run; /*Alternative 1*/ %macro datasets(name= ); data work.&amp;name; set sashelp.class; where name=&quot;&amp;name&quot;; run; %mend datasets; data _null_; set sashelp.class; call execute(&#39;%datasets(name=&#39;||strip(name)||&#39;);&#39;); run; /*Alternative 2*/ proc sql; create table work.Vars as select name,type from dictionary.columns where memname=&quot;CLASS&quot; and libname=&quot;SASHELP&quot;; quit; %macro report(var= , type= ); %if &amp;type=char %then %do; proc freq data=sashelp.class; table &amp;var; run; %end; %else %do; proc means data=sashelp.class; var &amp;var; run; %end; %mend report; data _null_; set work.Vars; call execute(&#39;%report(var=&#39;||strip(name)||&#39; , type=&#39;||strip(type)||&#39;);&#39;); run; /*Code generated and executed by Call Execute:*/ %report(var=Age , type=num); %report(var=Sex , type=char); %report(var=Age , type=num); %report(var=Height , type=num); %report(var=Weight , type=num); 3.5.7.3 SYMGET CALL EXECUTE cannot change the currently executing DATA step. By using SYMGET, it is actually possible to work around that limitation %let pet=&quot;CAT&quot;; data test; call execute (&#39;%let pet=DOG;&#39;); animal = &amp;pet.; put animal; run; %let pet=CAT; data test; call execute (&#39;%let pet=DOG;&#39;); animal = symget(&#39;pet&#39;); put animal; run; %let value = BEFORE; data _null_; call symput(&#39;value&#39;, &#39;AFTER&#39;); /* Double quotes permit resolution of &amp;VALUE during the initial phase of the DATA step*/ /* Double Quotes: value is BEFORE.*/ call execute(&quot;%put Double Quotes: value is &amp;VALUE..;&quot;); call execute(&#39;%put Single Quotes: value is &amp;VALUE..;&#39;); run; 3.5.8 %sysfunc get the observations %macro getNobsOf(data); proc sql noprint; select count(*) into: nobs from &amp;data; quit; %mend; %global nobs; %getNobsOf(sashelp.class); %put &amp;nobs; /* version 2 */ %macro getNobsOf(data); %local dsid; %local nobs; %local rc; %let dsid = %sysfunc(open(&amp;data)); %let nobs = %sysfunc(attrn(&amp;dsid, nobs)); %let rc = %sysfunc(close(&amp;dsid)); &amp;nobs %mend getNobsOf; %let nobs = %getNobsOf(sashelp.class); %put &amp;nobs; 3.6 Clean Up 3.6.1 Basic setting Cleaning OUTPUT SCREEN and LOG dm log &quot;clear&quot;; dm output &quot;clear&quot;; Alternatively, you can use a different DM statement that will not only clear the output screen but will also remove any leftover “residue” in the results window. dm ‘odsresults’ clear; Cleaning LIBNAME references libname &amp;&amp;new&amp;i clear; Cleaning TITLES and FOOTNOTES title1; footnote1; 3.6.2 Delete datasets Deleting with PROC SQL proc sql; drop table work.Venus_t8_2_3_9_2_d03_:, work.Venus_t8_2_3_9_2_d04_:; quit; Deleting with PROC DELETE proc delete data=work.Venus_t8_2_3_9_2_d03 work.Venus_t8_2_3_9_2_d04; run; Deleting with PROC Datasets proc datasets lib=work nolist; delete Venus_t8_2_3_9_2_d03_: ; quit; Delete All Data Sets from a Library proc datasets library=library-name kill nolist; quit; 3.6.3 Deleting Formats Delete Numeric Format proc format; value eye 1 = &quot;OD&quot; 2 = &quot;OS&quot;; value visit 1 =&quot;Screening&quot; 2 =&quot;Surgery&quot; 3 =&quot;D1&quot; 4 =&quot;W1&quot; 5 =&quot;M1&quot; 6 =&quot;M4-6&quot; 99 =&quot;Unscheduled&quot;; run; proc catalog catalog=work.formats; delete visit.format eye.format ; run; Delete Character Format proc format; value $ enrolled &#39;n_Screened&#39; = &#39;Screened&#39; &#39;n_enrolled&#39; = &#39;Randomized&#39; &#39;n_screen_failure&#39; = &#39;Randomization failure&#39; &#39;n_implanted_1&#39; = &#39;1^{super st} eye implanted&#39; &#39;n_implanted_2&#39; = &#39;2^{super nd} eye implanted&#39; &#39;n_One_eye_eligible&#39; = &#39;Only one eligible eye&#39; &#39;n_SES&#39; = &#39;Safety population&#39; &#39;n_ITT&#39; = &#39;modified Intention to Treat population&#39; &#39;n_PP&#39; = &#39;Per-protocol population^n&#39; &#39;n_completed_study&#39; = &#39;Completed study&#39; &#39;n_discontinued&#39; =&#39;Discontinued^n&#39; other=[$250.]; run; proc catalog catalog=work.formats; delete Enrolled.formatc; run; 3.6.4 Remove assigned formats format all will delete all the formats in the SAS dataset. PROC DATASETS lib=work; MODIFY dsn; FORMAT _all_; INFORMAT _all_; RUN; QUIT; remove only the formats and informats of specific variables in the SAS dataset. Proc DataSets Lib = Work; Modify dsn; Format heigt weight sex; Run ; Quit ; delete formats/informats of all character or numeric variables proc datasets lib=work; modify dsn; format _char_; *format _num_; run; Quit; 3.6.5 Delete macro variables %macro deleteALL; options nonotes; %local vars; proc sql noprint; select name into: vars separated by &#39; &#39; from dictionary.macros where scope=&#39;GLOBAL&#39; and not name contains &#39;SYS_SQL_IP_&#39; and not name contains (&#39;STUDY&#39;) and not name contains (&#39;REPORT&#39;) and not name contains (&#39;SPONSOR&#39;) and not name contains (&#39;SYSRANDOM&#39;) ; quit; %put &amp;vars.; %symdel &amp;vars; options notes; %put NOTE: Macro variables deleted.; %mend deleteALL; Alternative proc sql noprints; select name into:mymacrovars separated by &#39;&#39; from dictionary.macros where scope = &#39;GLOBAL&#39;; quit; %symdel &amp;mymacrovars mymacrovars; 3.6.6 Delete Macro With specifying the macro proc catalog cat=work.sasmacr; delete macro_name / et=macro; quit; proc catalog catalog = work.sasmacr kill force; run; Reset all %macro /**************************************************************************** Reset all %macro: Deletes a macro definition from the Work.SASMacr catalog.; Use DELETE parameter to list macro names to delete. Use KEEP parameter to list macro names to NOT delete. Calling it with no values will delete all macros not currently running. ****************************************************************************/ %macro macdelete(delete,keep); %local libname memname objname objtype fid i; %do i=1 %to %sysmexecdepth; %let keep=%sysmexecname(&amp;i) &amp;keep; %end; %if %length(&amp;delete) %then %let delete=and findw(&quot;&amp;delete&quot;,objname,&#39;,&#39;,&#39;sit&#39;); %let fid=%sysfunc(open( sashelp.vcatalg(keep=libname memname objname objtype where=(libname=&#39;WORK&#39; and objtype=&#39;MACRO&#39; and memname like &#39;SASMAC_&#39; and not findw(&quot;&amp;keep&quot;,objname,&#39;,&#39;,&#39;sit&#39;) &amp;delete)))); %if (&amp;fid) %then %do; %syscall set(fid); %do %while(0=%sysfunc(fetch(&amp;fid))); %put %sysfunc(compbl(Removing &amp;objname from &amp;libname catalog &amp;memname)); %sysmacdelete &amp;objname; %end; %let fid=%sysfunc(close(&amp;fid)); %end; %else %put %qsysfunc(sysmsg()); %mend macdelete; %macdelete; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
